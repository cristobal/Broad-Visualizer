package com.broad.core {	import flash.geom.Point;

	/**	 * Basic class that hold a 2d vector	 * 	 * @author Miguel Santirso	 * @author Cristobal Dabed	 */	public final class Vector2D	{						public function Vector2D(x:Number = 0, y:Number = 0)		{			_point = new Point(x, y);		}				/**		 * @private		 */ 		private var _point:Point;				/**		 * @readwrite x		 */ 		public function get x():Number		{			return _point.x;		}				public function set x(value:Number):void {			_point.x = value;		}				/**		 * @readwrite y		 */ 		public function get y():Number		{			return _point.y;		}				public function set y(value:Number):void  {			_point.y = value;		}				/**		 * Retorna la distancia hasta otras coordenadas		 */		public function distanceTo(destination:Vector2D):Number		{			return Math.sqrt(Math.pow(destination.x - x, 2) + Math.pow(destination.y - y, 2));		}						/**		 * Retorna el ángulo hasta otro vector (en radianes)		 */		 public function angleTo(destination:Vector2D):Number		 {			return Math.atan2(this.perpDot(destination), this.dotProduct(destination));		 }				/**		 * Retorna el producto escalar		 */		public function dotProduct(v:Vector2D):Number		{			return x*v.x + y*v.y;		}						public function perpDot(v:Vector2D):Number		{			return x*v.y - y*v.x;		}				/**		 * Le resta "v" a este vector		 */		public function minus(v:Vector2D):void		{			x -= v.x;			y -= v.y;		}				/**		 * @override		 * Normaliza el vector		 */		public function normalizeByMagnitude():void		{			x /= magnitude;			y /= magnitude;		}				/**		 * El módulo del vector		 */		public function get magnitude():Number		{			return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));		}				public function clone():Vector2D		{			return new Vector2D(x, y);		}	}	}